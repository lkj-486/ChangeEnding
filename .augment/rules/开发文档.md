---
type: "always_apply"
---

## **《故事编织者》：完整项目开发蓝图 (0-to-1 AI可读版)**

### 0\. 阶段零：项目奠基 (Phase 0: Project Foundation)

**目标:** 搭建一个专业、可扩展、可维护的开发环境。这是所有工作的起点。

1.  **技术栈选型:**

      * **后端:** Node.js + Express.js (提供API服务)
      * **前端:** React 或 Vue.js (构建现代化的用户界面)
      * **数据库:** PostgreSQL 或 MongoDB (用于持久化存储)
      * **ORM/ODM:** Prisma (简化数据库操作)
      * **语言:** TypeScript (为项目提供类型安全，对AI和大型项目友好)

2.  **环境搭建:**

      * 使用pnpm作为包管理器，并结合Turborepo作为构建系统。
      * 安装并配置`TypeScript`。
      * 配置`ESLint`和`Prettier`以保证代码风格统一。
      * 建立`Git`仓库，并创建`main`和`develop`分支。

3.  **项目结构规划 (Monorepo - 推荐):**

    ```
    /storyweaver/
    |-- /packages/
    |   |-- /api/         # 后端Express.js服务
    |   |-- /web/         # 前端React/Vue应用
    |   `-- /core/        # 核心游戏逻辑 (由api服务调用)
    |-- package.json      # Monorepo根配置文件
    `-- tsconfig.base.json
    ```

      * **说明:** Monorepo结构使得核心逻辑(`core`)可以被后端(`api`)轻松复用，也便于未来可能的其他应用（如桌面客户端）共享代码。

### 1\. 阶段一：核心引擎开发 (Phase 1: Core Engine Development)

**目标:** 实现之前Demo文档中定义的核心玩法闭环。这是项目最关键的创新部分。

1.  **核心模块实现 (`packages/core`):**

      * **世界状态 (`WorldState`):** 使用`geotic`库实现ECS，定义`Position`, `Identity`, `IsInScene`等核心组件。
      * **事件总线 (`EventBus`):** 使用`mitt`库作为全局事件中心。
      * **导演模块 (`Director`):**
          * 创建场景加载器，能从JSON文件读取场景配置。
          * 实现主游戏循环和状态机来管理场景的生命周期（`LOADING`, `RUNNING`, `PAUSED`, `ENDED`）。
          * 实现动作裁定和关键抉择点的识别逻辑。
      * **AI代理 (`AIAgent`):**
          * 创建能接收导演指令，并调用LLM规划动作的通用AI代理。
      * **叙事代理 (`NarrativeAgent`):**
          * 创建能监听`SCENE_UPDATED`事件，并调用LLM进行文学化渲染的叙事代理。
      * **玩家介入处理器 (`PlayerInterventionHandler`):**
          * 创建监听`CHOICE_POINT_RAISED`事件，并负责与外界（此阶段为API层）通信的处理器。

2.  **验收标准:** 所有核心模块都能在无UI的情况下，通过单元测试和集成测试证明其逻辑正确性。例如，可以编写一个测试脚本，模拟整个场景的运行，并验证其状态变化和事件触发是否符合预期。

### 2\. 阶段二：后端服务与持久化 (Phase 2: Backend Services & Persistence)

**目标:** 为核心引擎套上一个“外壳”，使其能通过网络提供服务，并能保存进度。

1.  **API服务搭建 (`packages/api`):**

      * 使用`Express.js`创建一个Web服务器。
      * **设计RESTful API端点:**
          * `POST /api/game/new`: 开始一个新游戏（选择一个故事剧本）。
          * `GET /api/game/:gameId`: 获取当前游戏状态和故事文本。
          * `POST /api/game/:gameId/choice`: 提交玩家在抉择点的选择。
          * `GET /api/stories`: 获取所有可玩的剧本列表。
      * **集成WebSocket:** 用于从服务器向客户端实时推送新的故事文本和抉择点选项。
      * **连接核心引擎:** API控制器调用`packages/core`中的游戏逻辑来处理游戏请求。

2.  **数据库集成 (`packages/api`):**

      * 使用`Prisma`定义数据模型：
          * `User`: 用户账户（可选，可后期添加）。
          * `Story`: 故事剧本的元数据。
          * `GameState`: 存储每个玩家正在进行的游戏的完整状态（序列化的ECS世界、导演状态等）。
      * **实现存读档逻辑:**
          * 在`POST /api/game/new`时，创建一个新的`GameState`记录。
          * 在`POST /api/game/:gameId/choice`后，更新对应的`GameState`记录。
          * 在`GET /api/game/:gameId`时，从数据库加载`GameState`并恢复游戏。

3.  **验收标准:** 可以通过Postman或Insomnia等API测试工具，完整地进行“开始游戏-\>做出选择-\>获取更新-\>游戏状态被保存”的整个流程。

### 3\. 阶段三：前端用户体验 (Phase 3: Frontend User Experience)

**目标:** 创建一个美观、易用、能充分展现故事沉浸感的用户界面。

1.  **UI/UX设计 (`packages/web`):**

      * **主故事流界面:** 采用类似小说的滚动式布局，新的文本从底部出现。对白、旁白、内心独白使用不同样式加以区分。
      * **选择界面:** 当抉择点出现时，故事流暂停，以模态框或嵌入式按钮的形式清晰地展示选项。
      * **侧边栏/信息面板:** 用于显示关键角色、地点、物品的信息。
      * **故事选择菜单:** 游戏开始前，以卡片形式展示所有可选的故事剧本。

2.  **前端开发 (`packages/web`):**

      * 使用`React`或`Vue`搭建项目。
      * 使用`Axios`进行API请求，使用`Socket.IO-client`处理WebSocket消息。
      * 实现状态管理（如Redux Toolkit或Pinia）来管理游戏状态、故事历史和UI状态。
      * 注重动画效果，如文本淡入、选择项出现时的动效，以增强体验。

3.  **验收标准:** 一个可部署的、功能完整的网站。用户可以在网站上选择一个故事，开始游玩，在关键节点做出选择，并完整地体验整个故事流程。

### 4\. 阶段四：内容创作与工具链 (Phase 4: Content Creation & Tooling)

**目标:** 让非程序员也能轻松地为游戏创作新的故事剧本。这是项目能否持续发展的关键。

1.  **剧本格式最终定稿:**

      * 设计一个强大且易于理解的`JSON`或`YAML`格式来定义一个完整的故事。它应包含：
          * 故事元数据（标题、作者、简介）。
          * 场景列表。
          * 每个场景的定义（目标、角色、初始状态、抉择点规则）。
          * 角色卡的定义。


### 5\. 阶段五：部署与运营 (Phase 5: Deployment & Operations)

**目标:** 将完整的应用发布到互联网上，并确保其稳定运行。

1.  **容器化:**

      * 为后端`api`服务和前端`web`应用分别创建`Dockerfile`。
      * 使用`docker-compose`来编排本地开发环境（包含后端、前端和数据库容器）。

2.  **CI/CD (持续集成/持续部署):**

      * 使用`GitHub Actions`或`GitLab CI`。
      * 配置工作流，使得每次向`main`分支推送代码时，能自动运行测试、构建Docker镜像并部署到服务器。

3.  **部署方案:**

      * **后端 (`api`):** 部署到云服务提供商（如AWS, Google Cloud, Azure）的容器服务（如ECS, Kubernetes）或PaaS平台（如Render, Railway）。
      * **前端 (`web`):** 部署到Vercel或Netlify等静态网站托管平台，它们对React/Vue项目有极佳的支持。
      * **数据库:** 使用云服务商提供的托管数据库服务（如AWS RDS, MongoDB Atlas）。

4.  **监控与日志:**

      * 集成日志服务（如Sentry, Logtail）来收集后端错误和性能数据。
      * 为关键API端点设置健康检查和告警。

5.  **验收标准:** 项目成功部署到公网，用户可以通过域名访问，所有功能在生产环境下正常工作。
